## 前言

端口扫描器在今天也有非常多的分支了, 面向不同的用户不同的场景不同的环境. 

- 有专注于端口开放情况的MX1014(TCP), masscan(SYN), 无法解决漏报问题, 或者功能太过单一
- 有传统的老牌全能扫描器nmap, 功能强大但最强的地方不是端口探测, 而是传输层的各种手法
- 有自定义传输层协议的扫描器sx, naabu, 类似go版本的nmap
- 以及这两年很火的各种红队向扫描器: fscan,kscan,yasso等等, 功能较多, 但缺乏打磨
- 内网网段探测扫描器, netspy, 功能较为单一

还有非常多的各类细枝末节的扫描器. 

而gogo的定位则是内网的网段探测,端口探测, 指纹识别与poc验证. 抛弃了各种服务弱口令爆破的功能.

原因是 端口探测, 指纹识别与poc验证 实际上是一条流水线上的工作, 逻辑上前后连续一致, 甚至不会带来多大的性能负担. 各种服务的弱口令则引入了不一致性, 需要新增很多配置参数, 引入很多库, 引入各种各样的代码. 因此,弱口令爆破这一块,将独立实现.

本文将描述gogo设计中需要解决的问题,以及解决的方案.

## 设计

- 快,  在保证最大兼容性的情况下, 经可能的快。
- 可控,  工具应该作为手与脑的衍生, 而非仅限于一把梭
- 可拓展, 需要可拓展的同时又要避免造轮子, gogo并不希望把世界上的所有poc重新实现一遍
- 可处理, 数据分析应该经可能的交给计算机去做, 人类并不适合做复杂数据的分析

gogo的定位始终是自动化引擎, 而非一个全能的扫描器, 添加漏洞扫描功能只是为了方便自动化, 而非以扫描能力为主.  作为一个自动化引擎, gogo的大脑始终是人, 但gogo可以帮助人去完成99%复杂繁琐的工作, 让人能将注意力集中在更有价值的事情上.

### 快

在对一些常见的扫描器调研之后以及对编程，网络的原理学习之后，发现快并非是线程数越高越好。要达到快还有很多限制条件以及对应的解决方案。
#### 并发
最常见地解决方案就是提高线程数，例如早期扫描器多是单线程，或者10，20的线程数，例如御剑，python开发的一些扫描器以及一些国外的简单发包工具。 虽然他们支持多线程，但是对高线程数的支持并不好。原因可能在于当年协程这一概念没有广泛使用，也有可能是生态中没有简单的解决方案。使用系统的多线程API，将会在多个方面带来大量额外的性能消耗。

1. 需要在内核层与用户层不断切换
2. 不断还原与保存高达4M的线程堆栈
3. 为了线程安全使用的各种锁带来的耗时
...

以及一些我尚不知道的性能消耗，导致多线程的应用很难进行数百甚至数千线程的并发。

在2021年的今天，go提供了简单可靠方便的高并发解决方案，可以在一C1G的低配VPS上实现数千个goroutine的调度。只需要使用go关键字，就能随意的实现数千个协程的并发，协程的调度将由go进行，不再需要系统调度的大量无用消耗。

当然，go的协程调度也不是无损，为了减少这个消耗，我们可以采用复用协程池的方式尽可能地减少消耗.


#### 网络
**tcp拥塞控制**

都学过tcp有拥塞控制, 但是这个拥塞控制是针对每一条tcp信道自身的,不会影响到其他tcp信道. 因此只有在传输大数据的时候,才会有性能影响. 对于端口扫描这样的场景, 每条tcp信道并不会有非常多的数据交互, 因此不受tcp拥塞控制影响. 但是网络拥塞会确确实实的影响到扫描准确率. 这是因为刚才提到的路由器的问题, 在路由的过程中, 网络拥塞 每个ttl的时间就会增加.

所以判断网络是否拥塞,可以判断ttl耗时的变化.  

**路由器的tail drop**

在测试扫描的过程中, 有几次把家里的华为路由器打挂了, 直接重启了.

后来才知道, 扫描的限制可能不来自代码, 也不来自系统, 而是路由器. 如果路由器网络拥塞了, 会采用tail drop(丢到队列末尾的数据包)来告诉客户端的tcp拥塞了,启用tcp拥塞控制,慢点发包. 而如果再负载再大一点, 路由器可能会直接重启. 重启这种问题主要再家用路由器上, 企业级路由器面对几千的并发还是没有任何问题的.

**tcp keep-alive**

http1.1中,实现了keep-alive,不再需要每次http重写建立一次握手,浪费大量资源. 

因此在http端口扫描,指纹识别,以及打poc的过程中, 都可以利用这个keep-alive长连接.

但是对于tcp端口, 则不适用这个keep-alive, 因为某些服务, 只有第一个包正确了才会返回对应的信息, 否则要么server主动断开连接,要么不再返回信息. 所以每个tcp端口扫描都建议重新建立连接.

**time-wait**

time-wait状态代表着tcp连接已经关闭, 但是fd还被占用,等待可能的后续数据处理, 防止有包迷失在网络中被污染下一个使用这个端口的fd.

如果不能正确的处理这个问题, 可能导致fd与端口资源耗尽.


#### 系统限制
gogo选择了尽可能不依赖第三方库, 以此来做到最大可能的兼容下保证. 目前可以在linux低版本内核(最低测试到2.x), bsd, 各种版本的mips与arm架构以及 最低到windows server 2003上跑. 应该能覆盖到99%的场景了, 有些系统没有环境去测试, 不过大概率是兼容的. 可以自行手动编译.

go.sum可以看到中有些递归的依赖, 实际上并没有调用到相关函数, 因此在编译的时候会自动跳过.

**windows 线程调度**

windows 的线程调度性能显然不如linux. 这里指的不只是并发控制, 还有tcp堆栈以及其他各种各样的消耗.

在使用windows进行扫描的时候, 经常会导致网络崩溃, 需要好几分钟才能回复. 或者是产生非常大量的漏报, 或者是识别不到http协议,只能建立tcp握手等等问题

在windows进行扫描遇到了非常多的信息, 最终只能降低线程数妥协windows.

**最大fd限制**

老版本的linux默认的fd限制为1024, 部分新版本的linux发行版改成了65535, 如果要修改需要root权限指定`limits -n 65535`修改.

windows中也有类似的限制, 默认大概是5000, 需要修改注册表修改, 万幸(带引号)的是windows大部分情况根本跑不到4000网络就崩溃了.

**65535最大端口数限制**

每个系统可用的端口都只有65535个, 而在http扫描的时候, 部分语言,例如go带复用连接池,自动开启keep-alive, 导致端口被长时间占用, 不能正确的松开. 其他一些语言,例如C#也有类似问题.



这里面的每个坑我几乎都踩过, 并花费了一些时间去寻找合适的解决办法, 并最终将其武器化/自动化积累在gogo之中

### 可控

gogo几乎将一个阶段的逻辑, 每个细节的控制都封装成了一个一个命令行参数, 这也是gogo存在一定入门门槛的原因. 当然, 绝大多数情况下, 用不到这些全部复杂的参数, 但在需要的时候, 你一定能从gogo中找到解决办法.  并且gogo也提供了便捷的workflow, 将一些常用的参数组合封装为了workflow, 仅需要一个参数即可调用非法复杂的扫描逻辑.



### 可拓展

为了可拓展性, xray采用了强依赖go-cel解释器编写poc, 导致poc很难移植, 因此放弃了xray的poc. 部分python poc框架, 例如pocsuite则是直接采用python编写代码, 更难迁移到其他平台. goby提供了一个图形化的poc生成工具, 方便了不少, 不过并不开源.

因此最终poc上选择了兼容nuclei, 好在nuclei的社区是目前最活跃的漏洞风险社区, 囊括了绝大部分用得到的漏洞. 

gogo也在尽可能在其他地方追求可拓展性. 目前可通过配置文件拓展的功能有很多, 可见 [拓展编写](/gogo/extension)

### 可处理

为了应对可能出现的各种奇怪的场景, 在使用gogo时, 可能需要来回多次对gogo的扫描结果再次扫描, 或者导入到其他工具中. gogo提供了一个强大的输出/输出 逻辑, 可以自由的控制输入与输出的格式, 并导出为合适的格式给其他工具或者辅助人类进行数据的二次分析. 

## Feature

gogo经过接近两年的实战打磨,  自认为已经在用户体验上做到了我们的最大可能. 但随着功能越来越复杂, 还是有不小的学习成本.

### 启发式扫描

在nmap,masscan那个年代, 对内网的扫描很少会超过c段, 更别说a段这种在当时几乎不可能完成的任务.

就算是现在的fscan, 或者相关特化的工具netspy也不能很好的实现, 只停留在勉强能用的阶段.

而gogo在很早就集成了根据经验公式的递归下降去发现网段. 并且通过生成器对扫描逻辑解耦, 可以任意组合不同的扫描阶段. 例如

* 想绘制一下当前入口点能通的网络拓扑 (大约30分钟)
* 只想看看10段内网里有多个B段被使用了 (大约30秒)
* 只想看看10网段中有多少ip存活 (大约30分钟)
* 想扫描下10段中的资产 (看前两阶段存活的资产数量, 大约1-2小时)
* 不仅想扫描资产, 还想识别下指纹, 探测下漏洞 (基本和探测资产时间相同, 采用最小发包原则,探测指纹与漏洞不会多耗时多少, 大约多20-30%耗时)
* 我想一口气把10,172,192内网全探测了, 并输出报告 (看资产数量, 大约1-2小时)
* ......

当然, 这里的网段可以自定义, 不一定是10.  大致可以理解为fscan与netspy的结合, 实际上会更加复杂一点.

用命令行构造这些场景较为复杂, 经过不少朋友试用吐槽后, 添加了workflow, 只需要一个参数即可覆盖绝大多数常见的使用场景. 具体的使用说明见仓库中的README.md与设计文档.

### 便捷的端口配置

刚才提到的启发式扫描, 主要是在扫描逻辑上的配置, 而对于具体端口资产, gogo也提供了及其方便的端口预设,

例如我要扫描常见的http服务, 指定`-p top3` 或 `-p top2` 即可. 如果要扫描数据库, 则是`-p db`

如果我同时要使用多个预设, 那么`-p top3,db,win`

如果我要使用多个预设, 又要指定某个区间网段. 那么 `-p top3,db,win,40000-50000`

通过name与tags的交叉管理, 能快速配置各种使用场景.

如果要添加预设, 可以在github的gogo-template中的port.yaml提交pr.


### 指纹识别

gogo的指纹与漏洞都将完全以dsl的方式实现, 说人话就是 通过yaml配置.

指纹是我自行设计的规则库格式与引擎, 因为并没有找到一个完全能满足我需求的规则库与引擎, 所以只能自己写一个, 整合了fofa的规则库, 以及fingerprinthub, fscan, kscan, allin中的一部分规则.

指纹识别看起来简单, 但我们在实战中遇到了一个接一个预期外的问题. 指纹识别并不是只匹配关键字就能做好.

例如, 某个http站, 访问会通过30x跳转,  但是跳转过去的站是个404页面(默认配置的蓝凌oa).

又例如, 某个http站, 直接访问80端口返回的是一个通过js进行跳转的页面, 这种情况指纹匹配不一定能生效.

再例如, 某个http站, 一访问就会下载文件, 那个文件可能有几百M大小,

如果是非http协议的端口, 那情况就更多了.

例如, 某些服务, 建立完握手就会返回banner, 如果你发送了它无法识别的数据, 他就会reset tcp链接(SSH).

又例如, 如果对某些服务发送了他无法识别的数据, 他不会断开tcp链接, 但是不再会返回数据(MSSQL).

再例如, 某些协议有各种各样的发行版, 每个发行版的banner都不同, 并且没有明显的规律(FTP与TELNET).

好在nmap已经解决了服务指纹的大部分问题, 只是如果直接使用nmap的指纹库, 过于庞大的指纹库会带来不必要的性能消耗.  某些扫描器就直接使用nmap的指纹库, 导致指纹匹配的时间大于扫描的时间. 让我能把注意力集中在http指纹识别上.

光是http指纹识别的特殊情况甚至超过了gogo能处理的范围, 如果加上这些功能, gogo不可避免的会变得臃肿, 因此, 部分http指纹识别的功能, 特别是主动指纹探测相关功能, 我将其移植到另一款工件中.  只在gogo中保留最基本的主动识别. 在内网绝大多数情况, 漏报一两个指纹并不会影响我们的后续操作. (毕竟就算漏报了, 对普通用户来说也是没有感知的lol)

### 漏洞探测

漏洞扫描相关功能从nuclei学到了不少东西, dsl语法也直接使用了nuclei, 但为了更加适配内网场景, 做了不少改动, 并不能完全兼容.  考虑到了内网环境, 我删除了一部分不必要的功能(动态dsl, oast等), 以简化二进制文件大小.   也添加了一些功能, 详情见github仓库中的poc.md,

绝大多数poc都可以从nuclei中移植poc, 只需要做一些简单修改与测试便可以快速加入到gogo中.  不过为了保证poc质量以及内网使用场景, 加入到gogo中的漏洞需要一定的筛选.

这里的考量是, 红队场景中, 对于各种oa, cms, 不少人都手握0day, 只需要做指纹识别与版本识别, 需要打poc的情况不太多. 对于一些设备, 开源组件 手动一台一台测试弱口令不太现实, 需要自动化探测默认密码以及开源组件的nday.

因此, gogo的漏洞库不会是一个大而全的漏洞库, 如果有大而全的需求, 可以直接使用nuclei.

我想通过兼容nuclei的生态, 让自己维护poc库省力一些, 现在基本处于有人反馈常见什么poc, 我就添加对应的poc, 经过一段时间的维护, 基本上常见的poc都能适配好. 需要各位大哥帮我实现.

这里你也会发现, 内网除了自动化打一些poc, 还可以把默认口令这部分给实现了, 一些常见的网络设备web端, web应用, 不再需要手动测试. 与其维护一个默认口令库, 不如直接自动化探测.

当然也支持自定义口令的批量爆破, 不过使用相对复杂, 属于进阶用法, 请详细阅读设计文档.

### 为什么没有服务的口令爆破

刚才提到了, 对web端默认口令的爆破gogo可以实现, 但有很多人问我, 为什么不把ssh, mysql之类的爆破也做进去?

最初我也是这么想的, 但是考虑到加上了这些功能, 二进制文件和代码会变得臃肿, 并且这些功能其实可以已另一种形式实现. 最终我们决定另起炉灶, 维护了另外一个工具 zombie, 主要用于批量的服务弱口令爆破与利用. gogo与zombie可以联动, gogo导出的zombie可识别的格式, 然后再通过代理或者上传zombie本体进行爆破.

这也是变相鼓励使用者不要在内网进行大规模的服务弱口令爆破, 大多数厂商的流量设备对服务弱口令爆破是很敏感的, 大多数都是严重或者高危的告警. gogo默认情况下只进行高速率的http发包, 不会发送poc, 经常会被其他告警淹没而忽略了gogo的扫描行为. 实际使用体验 因为高速率发包而被发现的情况较少.

通过gogo的筛选功能与zombie的自定义功能, 可以对想要爆破的密码本与目标进行精准管控, 尽量减少不必要的发包以规避流量设备的检测. 如果有可能, 最好只进行密码喷洒, 而非爆破.

在我们的规划中, zombie能做的不仅仅是口令的爆破, 还可以实现一些自动化的利用, 比如mysql爆破之后, 判断下是否是root, 有多少数据, 自定义的命令批量执行等等功能. 批量的rce更不是梦, 只不过因为工作量问题, 这部分只能一小块一小块的实现, 目前的zombie已经支持了十几种协议, 能覆盖到90%以上的hw使用场景. 让护网不再是一个一个登录上去截图, 而是gogo与zombie的快乐联动, 内网刷分, 一行命令!

可以发现gogo与zombie的场景也不完全一致, zombie完全可以放在外网, 通过代理接入, 减轻zombie引入大量库的免杀压力.

在未来, 我打算编写一个gui界面的结果解析器与联动工具, 也可以是与c2 webshell的联动, 进一步简化操作, 让gogo与zombie的联动无缝衔接.

### 其他

gogo最核心的几块功能就是我刚才提到的, 但实际上还有不少细节我没有一一介绍, 使用者可以在实战中慢慢体会, 或者阅读仓库中的设计文档(不过写得不太好, 会慢慢整理修改), 也欢迎提出新的需求以及pr.

具体的使用请看README.md 与--help.

gogo是整个计划版图中发布的第一块拼图, 也是目前最成熟的部分. 祝各位用的开心!

其他工件会在整理完成后逐步开放.



gogo的使用较为复杂, 在开发时也没做好文档, 注释与单元测试 这方面将会在未来补上. 如果有不清晰的用法, 可以在issue中提出, 我看到后会及时回复.


## 未来展望

1. 集成到自动化外网信息收集工具, 与图数据库相结合 (已经做了一部分)
2. 自动收集结果, 以可视化报告的形式呈现 (已经做了一部分)
3. 与webshell, c2工具联动, 实现图形化 一键使用 (已经做了一部分)
4. 与maitai(暂未公开的代理工具)联动, 实现gogo流量的高性能转发.
5. 内网分布式部署, 多点同时扫描
6. agent化, 特殊网络环境下, 可以只上传tiny agent (通过maitai实现, todo)
